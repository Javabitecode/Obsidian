https://www.baeldung.com/java-stack-heap

```java
class Person {  
    int id;  
    String name;  
  
    public Person(int id, String name) {  
        this.id = id;  
        this.name = name;  
    }  
}  
  
public class PersonBuilder {  
    private static Person buildPerson(int id, String name) {  
        return new Person(id, name);  
    }  
  
    public static void main(String[] args) {  
        int id = 23;  
        String name = "John";  
        Person person = null;  
        person = buildPerson(id, name);  
    }  
}
```

Давайте проанализируем это шаг за шагом:

1.  Когда мы входим в метод _main()_ , в памяти стека создается место для хранения примитивов и ссылок этого метода.
    -   Память стека напрямую хранит примитивное значение целочисленного _идентификатора._
    -   В памяти стека также будет создана ссылочная переменная _person_  типа _Person  , которая будет указывать на реальный объект в куче._
2.  Вызов параметризованного конструктора  _Person(int, String)_ из _main()_  выделит дополнительную память поверх предыдущего стека. Это будет хранить:
    -   Ссылка на _этот_ объект вызывающего объекта в памяти стека
    -   _Идентификатор_  примитивного значения  в памяти стека
    -   Ссылочная переменная имени аргумента _String_ _,_ которая будет указывать на фактическую строку из пула строк в куче памяти.
3.  Основной метод — это дальнейший вызов статического метода _buildPerson_ _()_ , для которого дальнейшее выделение будет происходить в памяти стека поверх предыдущего. Это снова сохранит переменные в порядке, описанном выше.
4.  Однако в памяти кучи будут храниться все переменные экземпляра для вновь созданного объекта _person_ типа  _Person._

Давайте посмотрим на это распределение на диаграмме ниже:

![[memory_1.png]]

![[memory_2.png]]
# Проблемы транзакции

### 1. Зависание транзакции.
```sql
BEGIN;  
EXPLAIN ANALYSE  
DELETE  
FROM car.car  
WHERE id  
          IN (SELECT d.id  
              FROM delete_table d  
              WHERE d.flag IS NULL  
              LIMIT 10000);  
ROLLBACK;
```
https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-SIGNAL-TABLE
https://stackoverflow.com/questions/11291456/terminate-hung-query-idle-in-transaction
Описание:
Длительное «ожидание в транзакции» часто означает, что транзакция не была завершена «фиксацией» или «откатом», что означает, что приложение содержит ошибки или не предназначено для работы с транзакционными базами данных. Следует избегать длительного простоя в транзакции, так как это также может вызвать серьезные проблемы с производительностью.

Решение проблемы:
Найдите PID, запустив этот sql:

```sql
SELECT pid , query, * from pg_stat_activity
  WHERE state != 'idle' ORDER BY xact_start;
```
(Запрос может нуждаться в исправлении в зависимости от версии postgres — в конце концов, просто выберите * из pg_stat_activity). Вы найдете pid в первом (левом) столбце, а первая (верхняя) строка, скорее всего, будет запросом, который вы хотите завершить. Я предполагаю, что pid равен 1234 ниже.

Вы можете отменить запрос через SQL (i.e. without shell access), если он принадлежит вам или у вас есть права суперпользователя:

```sql
select pg_cancel_backend(1234);
```

Это «дружеский» запрос на отмену 1234-запроса, и, если повезет, через некоторое время он исчезнет. Если требуется ! , следующая команда больше похожа на команду «жесткого завершения», которая может привести к более быстрой отмене:

```sql
select pg_terminate_backend(1234);
```

Если у вас есть доступ к оболочке и права root или postgres, вы также можете сделать это из оболочки. Чтобы «отменить», можно сделать:

```sql
kill -INT 1234
```

и "прекратить", просто:

```sql
kill 1234
```

## !!! **НЕ НАДО:**

```sql
kill -9 1234
```

... это часто приводит к тому, что весь сервер postgres сгорает, тогда вы также можете перезапустить postgres. Postgres довольно надежен, поэтому данные не будут повреждены, но я бы не рекомендовал использовать «kill -9» в любом случае :-).

2
### 2. Проблема фантомного чтения
Если уровень изоляции ниже Serializable =>
пока транзакция (например удаление 10 мл rows) не заверщится, данные удаленные в транзакции можно читать.
https://itnan.ru/post.php?c=1&p=682362
Вы можете использовать это руководство, чтобы получить простое и практическое понимание того, как работает управление транзакциями в **Spring** (Спринге) с помощью аннотации `@Transacional` .

Единственное необходимое условие? Вы должны иметь приблизительное представление об **ACID**, то есть о том, что такое транзакции баз данных и зачем их использовать. Также здесь не рассматриваются распределенные транзакции или реактивные транзакции, хотя общие принципы, с точки зрения **Spring** всё же применимы.

## Введение

В этом руководстве вы узнаете об основных столпах "_transaction abstraction framework"_("_структуры абстракции транзакций_" _-_ запутанный термин, не так ли?) **Spring core** - описанных с большим количеством примеров кода:

-   `@Transactional` (декларативное управление транзакциями) против программного управления транзакциями.
    
-   Физические и логические транзакции.
    
-   Интеграция `@Transactional` **Spring** и **JPA / Hibernate**.
    
-   Интеграция `@Transactional` **Spring** и **Spring Boot** или **Spring MVC**.
    
-   Откаты, прокси, общие проблемы и многое другое.
    

В отличие, скажем, от [официальной документации по Spring](https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/data-access.html#transaction-declarative) это руководство не запутает вас, погрузившись сразу в тему Spring-first.

Вместо этого вы будете изучать управление транзакциями **Spring** нетрадиционным способом: с нуля, шаг за шагом. Это означает, что вы начнёте со старого доброго управления [транзакциями JDBC](https://en.wikipedia.org/wiki/Java_Database_Connectivity).

Почему?

Потому что всё, что делает **Spring**, построено на этих самых основах **_JDBC_** (соединение с базами данных на Java**)**. И вы сэкономите кучу времени при работе с аннотацией `@Transactional` от **Spring**, если усвоите эти начала.

## Как работает обычное Управление транзакциями JDBC

Если вы думаете пропустить этот раздел, не зная транзакций **JDBC** изнутри: **не стоит**.

#### Как запускать, фиксировать или откатывать транзакции JDBC

Первый важный вывод заключается в следующем: Не имеет значения, используете ли вы аннотацию `@Transactional` от **Spring**, обычный **Hibernate**, **jOOQ** или любую другую библиотеку баз данных.

В конечном счёте, все они делают одно и то же - открывают и закрывают (назовём это "управлением") транзакции базы данных. Обычный код управления транзакциями **JDBC** выглядит следующим образом:

```
import java.sql.Connection;

Connection connection = dataSource.getConnection(); // (1)

try (connection) {
    connection.setAutoCommit(false); // (2)
    // выполнить несколько SQL-запросов...
    connection.commit(); // (3)

} catch (SQLException e) {
    connection.rollback(); // (4)
}
```

-   Для запуска транзакций необходимо подключение к базе данных. [DriverManager.getConnection(url, user, password)](https://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html) тоже подойдёт, хотя в большинстве корпоративных приложений вы будете иметь настроенный источник данных и получать соединения из него.
    
-   Это **единственный** способ "начать" транзакцию базы данных в **Java**, даже несмотря на то, что название может звучать немного странно. `setAutoCommit(true)` гарантирует, что каждый **SQL**-оператор будет автоматически завёрнут в собственную транзакцию, а `setAutoCommit(false)` - наоборот: Вы являетесь хозяином транзакции (транзакций), и Вам придётся начать вызывать `commit` и друзей. Обратите внимание, что флаг `autoCommit` действует в течение всего времени, пока ваше соединение открыто, что означает, что вам нужно вызвать метод только один раз, а не несколько.
    
-   Давайте зафиксируем нашу транзакцию...
    
-   Или откатим наши изменения, если произошло исключение.
    

Да, эти 4 строки - это (в упрощенном виде) всё, что **Spring** делает всякий раз, когда вы используете аннотацию `@Transactional` . В следующей главе вы узнаете, как это работает. Но прежде чем мы перейдём к этому, вам нужно узнать ещё кое-что.

(Небольшое замечание для умников: Библиотеки пулов соединений, такие как [HikariCP](https://github.com/brettwooldridge/HikariCP), могут переключать режим автокоммита автоматически, в зависимости от конфигурации. Но это уже продвинутая тема).

### Как использовать уровни изоляции JDBC и точки сохранения

Если вы уже играли с аннотацией `@Transactional` от **Spring**, вы могли столкнуться с чем-то подобным:

```
@Transactional(
  propagation=TransactionDefinition.NESTED,
  isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED
)
```

Мы рассмотрим вложенные транзакции **Spring** и уровни изоляции позже более подробно, но опять же полезно знать, что все эти параметры сводятся к следующему, основному коду **JDBC**:

```
import java.sql.Connection;

// isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED

connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); // (1)

// propagation=TransactionDefinition.NESTED

Savepoint savePoint = connection.setSavepoint(); // (2)
...
connection.rollback(savePoint);
```

-   Вот как **Spring** устанавливает уровни изоляции для соединения с базой данных. Не такое уж хитросплетённый, не так ли?
    
-   Вложенные транзакции в **Spring** - это просто точки сохранения **JDBC** / базы данных. Если вы не знаете, что такое точка сохранения, посмотрите, например, [это руководство](https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html). Обратите внимание, что поддержка точек сохранения зависит от вашего драйвера **JDBC**/базы данных.
    

## Как работает управление транзакциями в Spring или Spring boot

Поскольку теперь у вас есть хорошее понимание транзакций **JDBC**, давайте посмотрим, как [Spring core](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html) управляет транзакциями. Здесь всё применимо 1:1 к [**Spring boot**](https://spring.io/projects/spring-boot) и **Spring MVC**, но [об этом](https://itnan.ru/post.php?c=1&p=682362#Transactional%20%D1%81o%20Spring%20boot) чуть позже...

Что _на самом деле_ _представляет_ _собой_ управление транзакциями **Spring** или его (довольно запутанно названная) _структура абстракции транзакций_?

Помните, что управление транзакциями просто означает: Как **Spring** запускает, фиксирует или откатывает транзакции **JDBC**? Звучит ли это как-то знакомо?

Вот в чём загвоздка: В то время как в обычном **JDBC** у вас есть только один способ (`setAutocommit(false)`) управлять транзакциями, **Spring** предлагает вам множество различных, более удобных способов добиться того же самого.

### Как использовать "программное управление транзакциями Spring" (Programmatic Transaction Management)?

Первый, но довольно редко используемый способ определения транзакций в **Spring** - программный: Либо через транзакционный шаблон `TransactionTemplate`, либо непосредственно через `PlatformTransactionManager`. С точки зрения кода это выглядит следующим образом:

```
@Service
public class UserService {

    @Autowired
    private TransactionTemplate template;

    public Long registerUser(User user) {
        Long id = template.execute(status ->  {
            // выполнить некоторый SQL, который, например,
            // вставляет пользователя в базу данных 
            // и возвращает автогенерированный идентификатор
          return id;
        });
    }
}
```

По сравнению с [обычным примером JDBC](https://itnan.ru/post.php?c=1&p=682362#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80_JDBC):

-   Вам не нужно возиться с открытием и закрытием соединений с базой данных самостоятельно (`try-finally`). Вместо этого вы используете [обратные вызовы транзакций](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/transaction/support/TransactionCallback.html).
    
-   Вам также не нужно ловить `SQLExceptions`, поскольку **Spring** преобразует эти исключения в исключения времени выполнения (runtime exceptions).
    
-   Кроме того, вы лучше интегрируетесь в экосистему **Spring**. `TransactionTemplate` будет использовать `TransactionManager` внутри, который будет использовать источник данных. Все это бины, которые вы должны указать в конфигурации контекста **Spring**, но о которых вам больше не придётся беспокоиться в дальнейшем.
    

Хотя это и считается незначительным улучшением, программное управление транзакциями - это не то, чем в основном занимается транзакционная структура (transaction framework) **Spring**. Вместо этого, все дело в _декларативном управлении_ транзакциями. Давайте выясним, что это такое.

### Как использовать декларативное управление транзакциями XML от Spring?

В те времена, когда конфигурация XML была нормой для проектов **Spring**, вы могли конфигурировать транзакции непосредственно в XML. За исключением нескольких старых корпоративных проектов, вы больше не встретите такой подход в природе, поскольку он был вытеснен гораздо более простой аннотацией `@Transactional` .

В этом руководстве мы не будем подробно останавливаться на конфигурации XML, но вы можете использовать этот пример в качестве отправной точки, чтобы углубиться в него - при необходимости (он взят прямо из [официальной документации Sprnig](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html#transaction-declarative)):

```
<!-- транзакционный совет (advice) (что "происходит"; см. <aop:advisor/> бин ниже) -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <!-- семантика транзакций... -->
        <tx:attributes>
            <!--все методы, начинающиеся с 'get', доступны только для чтения -->
            <tx:method name="get*" read-only="true"/>
            <!-- другие методы используют настройки транзакции по умолчанию (см. ниже) -->
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>
```

Вы определяете [advice AOP](https://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/htmlsingle/#aop-introduction) (Aspect Oriented Programming, аспектно-ориентированное программировие) с помощью приведенного выше блока XML, который затем можно применить к бин `UserService` следующим образом:

```
<aop:config>
    <aop:pointcut id="userServiceOperation" expression="execution(* x.y.service.UserService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="userServiceOperation"/>
</aop:config>

<bean id="userService" class="x.y.service.UserService"/>
```

Тогда ваш бин `UserService` будет выглядеть следующим образом:

```
public class UserService {

    public Long registerUser(User user) { 
        // выполняем SQL, который, например.
        // вставляет пользователя в базу данных 
        // и извлекает автогенерированный id
      return id;
    }
}
```

С точки зрения кода Java, этот декларативный подход к транзакциям выглядит намного проще, чем программный подход. Но он приводит к большому количеству сложного, многословного XML с конфигурациями указателей и советников (advisor).

Таким образом, это приводит к вопросу: Есть ли лучший способ управления декларативными транзакциями вместо XML? Да, есть: аннотация `@Transacional` .

### Как использовать аннотацию @Transactional Spring (декларативное управление транзакциями, Declarative Transaction Management)

Теперь давайте посмотрим, как обычно выглядит современное управление транзакциями в **Spring**:

```
public class UserService {

    @Transactional
    public Long registerUser(User user) {
        // выполнить некоторый SQL, который, например,
        // вставляет пользователя в базу данных 
        // и извлекает автогенерированный id
        // userDao.save(user);
        return id;
    }
}
```

Как это возможно? Больше нет конфигурации XML, а также нет необходимости в другом коде. Вместо этого вам теперь нужно сделать две вещи:

-   Убедитесь, что ваша `Configuration` **_Spring_** сопровождена аннотацией `@EnableTransactionManagement` **Spring boot** _это будет сделано автоматически_).
    
-   Убедитесь, что вы указали менеджер транзакций в вашей `Configuration` **_Spring_** (это необходимо сделать в любом случае).
    

И тогда **Spring** покажет себя достаточно умным, чтобы явно обрабатывать транзакции для вас: Любой публичный `public` метод бин, который вы сопровождаете аннотацией `@Transactional` , будет выполняться _внутри_ _транзакции базы данных_ (обратите внимание: есть некоторые [подводные камни](https://itnan.ru/post.php?c=1&p=682362#%D0%BF%D0%BE%D0%B4%D0%B2%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D0%BA%D0%B0%D0%BC%D0%B5%D0%BD%D1%8C)).

Итак, чтобы аннотация `@Transactional` заработала, всё, что вам нужно сделать, это следующее:

```
@Configuration
@EnableTransactionManagement
public class MySpringConfig {

    @Bean
    public PlatformTransactionManager txManager() {
        return yourTxManager; // подробнее об этом позже
    }

}
```

Теперь, когда я говорю, что **Spring** явно обрабатывает транзакции для вас. Что это _означает на самом деле_?

Вооружившись знаниями из [примера транзакций JDBC](https://itnan.ru/post.php?c=1&p=682362#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%A1%D0%91%D0%94%D0%AF), приведённый выше код `@Transactional` `UserService` переводится (упрощенно) непосредственно следующим образом:

```
public class UserService {

    public Long registerUser(User user) {
        Connection connection = dataSource.getConnection(); // (1)
        try (connection) {
            connection.setAutoCommit(false); // (1)

            // выполнить некоторый SQL, который, например.
            // вставляет пользователя в базу данных 
            // и извлекает автогенерированный идентификатор
            // userDao.save(user); <(2)

            connection.commit(); // (1)
        } catch (SQLException e) {
            connection.rollback(); // (1)
        }
    }
}
```

-   Все это просто стандартное открытие и закрытие соединения **JDBC**. Это то, что транзакционная аннотация **Spring** делает для вас автоматически, без необходимости писать её явно.
    
-   Это ваш собственный код, сохраняющий пользователя через **DAO** или что-то подобное.
    

Этот пример может выглядеть немного _магическим_, но давайте посмотрим, как **Spring** вставляет этот код соединения для вас.

### CGlib и JDK прокси - @Transactional под прикрытием

**Spring** не может переписать ваш класс Java, как я сделал выше, чтобы вставить код подключения (если только вы не используете продвинутые техники, такие как плетение байткода (bytecode weaving), но мы пока опускаем это).

Ваш метод `registerUser()` действительно просто вызывает `userDao.save(user)`, и нет способа изменить это на лету.

Но у Spring есть преимущество. По своей сути это IoC container (_контейнер инверсии контроля_). Он создаёт для вас экземпляр `UserService` и обеспечивает автоподключение этого `UserService` к любому другому бины, которому нужен этот `UserService`.

Теперь, когда вы используете `@Transactional` над бинами, **Spring** использует маленькую хитрость. Он не просто инстанцирует `UserService`, но и транзакционный _прокси_ этого `UserService`.

Он делает это с помощью метода под названием `proxy-through-subclassing` с помощью [библиотеки Cglib](https://github.com/cglib/cglib). Существуют и другие способы построения прокси (например, [Dynamic JDK proxies](https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html)), но пока оставим это на потом.

Давайте посмотрим на прокси в действии на этом рисунке:

![](https://habrastorage.org/getpro/habr/upload_files/931/dcd/ea3/931dcdea3fe31c8828c463a099eca02a.png)

Как видно из этой диаграммы, у конкретного прокси есть одна задача.

-   Открытие и закрытие соединений/транзакций с базой данных.
    
-   А затем делегирование настоящему `UserService`, тому, который вы написали.
    
-   А другие бины, такие как ваш `UserRestController`, никогда не узнают, что они разговаривают с прокси, а не с настоящим.
    

### Короткий тест

Посмотрите на следующий исходный код и скажите мне, какой тип `UserService` автоматически конструирует **Spring**, предполагая, что он помечен `@Transactional` на уровне класса или имеет на уровне метода внутри класса конфигурации.

```
@Configuration
@EnableTransactionManagement
public static class MyAppConfig {

    @Bean
    public UserService userService() {  // (1)
        return new UserService();
    }
}
```

Ответ

### Для чего вам нужен менеджер транзакций (например, PlatformTransactionManager)?

Теперь не хватает только одной важной части информации, хотя мы уже несколько раз упоминали о ней.

Ваш `UserService` проксируется на лету, и прокси управляет транзакциями для вас. Но не сам прокси управляет всем этим транзакционным состоянием (открыть, зафиксировать, закрыть), прокси делегирует эту работу менеджеру транзакций.

**Spring** предлагает вам интерфейс `PlatformTransactionManager` / `TransactionManager`, который по умолчанию поставляется с парой удобных реализаций. Одна из них - менеджер транзакций источника данных.

Он делает то же самое, что вы делали до сих пор для управления транзакциями, но сначала давайте рассмотрим необходимую конфигурацию **Spring**:

```
@Bean
public DataSource dataSource() {
    return new MysqlDataSource(); // (1)
}

@Bean
public PlatformTransactionManager txManager() {
    return new DataSourceTransactionManager(dataSource()); // (2)
}
```

-   Здесь вы создаёте источник данных, специфичный для базы данных или для пула соединений. В данном примере используется **MySQL**.
    
-   Здесь вы создаёте свой менеджер транзакций, которому нужен источник данных, чтобы иметь возможность управлять транзакциями.
    

Всё просто. Все менеджеры транзакций имеют методы типа "`doBegin`" (для запуска транзакции) или "`doCommit`", которые выглядят следующим образом - взяты прямо из исходного кода **Spring** с некоторым упрощением:

```
public class DataSourceTransactionManager implements PlatformTransactionManager {

    @Override
    protected void doBegin(Object transaction, TransactionDefinition definition) {
        Connection newCon = obtainDataSource().getConnection();
        // ...
        con.setAutoCommit(false);
        // Да, вот так.!
    }

    @Override
    protected void doCommit(DefaultTransactionStatus status) {
        // ...
        Connection connection = status.getTransaction().getConnectionHolder().getConnection();
        try {
            con.commit();
        } catch (SQLException ex) {
            throw new TransactionSystemException("Could not commit JDBC transaction", ex);
        }
    }
}
```

Таким образом, менеджер транзакций источника данных использует при управлении транзакциями точно такой же код, который вы видели в разделе **JDBC**.

Учитывая это, давайте расширим наш рисунок сверху:

![](https://habrastorage.org/getpro/habr/upload_files/410/262/217/410262217ed70ef29ef9e0cc5e839c78.png)

Подведем итоги:

-   Если **Spring** обнаруживает аннотацию `@Transactional` на бины, он создаёт динамический прокси этого бины.
    
-   Прокси имеет доступ к менеджеру транзакций и будет просить его открывать и закрывать транзакции/соединения.
    
-   Сам менеджер транзакций будет просто делать то, что вы делали в разделе "[Простой JDBC](https://itnan.ru/post.php?c=1&p=682362#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80_JDBC)": Управлять старым добрым соединением **JDBC**.
    

### В чём разница между физическими и логическими транзакциями?

Представьте следующие два класса транзакций.

```
@Service
public class UserService {

    @Autowired
    private InvoiceService invoiceService;

    @Transactional
    public void invoice() {
        invoiceService.createPdf();
        // отправка счёта по электронной почте и т.д...
    }
}

@Service
public class InvoiceService {

    @Transactional
    public void createPdf() {
        // ...
    }
}
```

`UserService` имеет транзакционный метод `invoice()`. Который вызывает другой транзакционный метод, `createPdf()` на `InvoiceService`.

Теперь, с точки зрения транзакций базы данных, это должна быть всего лишь одна транзакция базы данных. (Помните: `getConnection().setAutocommit(false).commit())`. **Spring** называет это _физической_ транзакцией, хотя сначала это может показаться немного запутанным.

Однако со стороны **Spring** происходит две _логические транзакции_: Первая - в `UserService`, вторая - в `InvoiceService`. **Spring** должен быть достаточно умным, чтобы знать, что оба метода `@Transacional` должны использовать _в основе_ одну и ту же _физическую_ транзакцию базы данных.

Как изменится ситуация при следующем изменении `InvoiceService`?

```
@Service
public class InvoiceService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}
```

Изменение режима распространения (propagation) на `requires_new` говорит **Spring**, что `createPDF()` должна выполняться в собственной транзакции, независимо от любой другой, уже существующей транзакции. Вспоминая раздел данного руководства, посвященный [простой Java](https://itnan.ru/post.php?c=1&p=682362#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80_JDBC), видели ли вы способ "разделить" транзакцию пополам? Я тоже.

Это означает, что ваш код будет открывать **два** (физических) соединения/транзакции с базой данных. (Снова: `getConnection()` _x2_`. setAutocommit(false)` _x2_`. commit()` _x2_). **Spring** теперь должен быть достаточно умным, чтобы две логические транзакции (`invoice()`/`createPdf()`) теперь также отображались на две разные физические транзакции базы данных.

Итак, подведем итоги:

-   Физические транзакции: это ваши фактические транзакции **JDBC**.
    
-   Логические транзакции: это (потенциально вложенные) аннотированные `@Transactional` методы **Spring**.
    

Это подводит нас к более подробному рассмотрению режимов распространения.

#### What are @Transactional Propagation Levels used for?

Изучая исходный код **Spring**, вы найдете множество уровней или режимов распространения, которые можно подключить к методу `@Transactional`.

```
  @Transactional(propagation = Propagation.REQUIRED)

  // или

  @Transactional(propagation = Propagation.REQUIRES_NEW)
  // и т.д.
```

Полный перечень:

-   `REQUIRED`
    
-   `SUPPORTS`
    
-   `MANDATORY`
    
-   `REQUIRES_NEW`
    
-   `NOT_SUPPORTED`
    
-   `NEVER`
    
-   `NESTED`
    

### Упражнение:

В разделе "[Обычный JDBC](https://xn--__jdbc-3ofxh6asalekfdjt/)" я показал вам всё, на что способен **JDBC**, когда речь идёт о транзакциях. Потратьте минуту, чтобы подумать о том, что каждый отдельный режим распространения в **Spring** в итоге НА САМОМ ДЕЛЕ делает с вашим источником данных или, скорее, с вашим соединением **JDBC**.

Затем посмотрите на следующие ответы.

Ответы

-   **Required (по умолчанию)**: Моему методу нужна транзакция, либо откройте ее для меня, либо используйте существующую → `getConnection().setAutocommit(false).commit()`
    
-   **Supports**: Мне не важно, открыта транзакция или нет, я могу работать в любом случае → не имеет отношения к **JDBC**
    
-   **Mandatory**: Я не собираюсь открывать транзакцию сам, но я буду плакать, если никто другой не откроет её → не имеет отношения к **JDBC**
    
-   **Require_new:** Я хочу полностью собственную транзакцию → `getConnection().setAutocommit(false).commit()`
    
-   **Not_Supported:** Мне очень не нравятся транзакции, я даже попытаюсь приостановить текущую, запущенную транзакцию → ничего общего с **JDBC**
    
-   **Never:** Я буду плакать, если кто-то другой запустит транзакцию → не имеет отношения к **JDBC**
    
-   **Nested:** Это звучит так сложно, но мы просто говорим о точках сохранения! → `connection.setSavepoint()`
    

Как вы можете видеть, большинство режимов распространения на самом деле не имеют ничего общего с базой данных или **JDBC**, но больше с тем, как вы структурируете свою программу со **Spring** и как/когда/где **Spring** ожидает присутствия транзакций.

Посмотрите на этот пример:

```
public class UserService {

     @Transactional(propagation = Propagation.MANDATORY)
     public void myMethod() {
        // выполнить sql
     }

}
```

В этом случае **Spring** будет ожидать, что транзакция будет открыта, когда вы вызовете `myMethod()` класса `UserService`. Он не открывает её сам, вместо этого, если вы вызовете этот метод без предварительно существующей транзакции, **Spring** выбросит исключение. Помните об этом как о дополнительных нюансах для "логической обработки транзакций".

### Для чего используются @Transactional уровни изоляции?

Это почти вопрос с подвохом, но что произойдет, если вы настроите аннотацию `@Transactional` таким образом?

```
@Transactional(isolation = Isolation.REPEATABLE_READ)
```

Да, это просто приводит к этому:

```
connection
    .setTransactionIsolation(
            Connection.TRANSACTION_REPEATABLE_READ
    );
```

Уровни изоляции базы данных, однако, являются сложной темой, и вам следует потратить некоторое время, чтобы полностью разобраться в них. Хорошим началом является официальная документация **Postgres** и ее раздел [об уровнях изоляции](https://www.postgresql.org/docs/9.5/transaction-iso.html).

Также обратите внимание, что когда речь идет о переключении уровней изоляции во время транзакции, вы должны обязательно проконсультироваться о вашем драйвере **JDBC**/базы данных, чтобы понять, какие сценарии поддерживаются, а какие нет.

### Самый распространенный "подводный камень" @Transactional

Есть один подводный камень, на который обычно наталкиваются начинающие разработчики **Spring**. Взгляните на следующий код:

```
@Service
public class UserService {

    @Transactional
    public void invoice() {
        createPdf();
        // отправка счета по электронной почте и т.д.
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}
```

У вас есть класс `UserService` с транзакционным методом `invoice()`. Который вызывает `createPDF()`, который также является транзакционным.

Сколько физических транзакций, по вашему мнению, будет открыто, когда кто-то вызовет `invoice()`?

Нет, ответ будет не два, а один. Почему?

Давайте вернемся к разделу "Прокси" этого руководства. **Spring** создает для вас транзакционный прокси `UserService`, но как только вы оказываетесь внутри класса `UserService` и вызываете другие внутренние методы, прокси больше не задействован. Это означает, что новой транзакции не будет.

Давайте посмотрим на это на рисунке:

![](https://habrastorage.org/getpro/habr/upload_files/32c/564/4b8/32c5644b84e8b80fa7eb9fb4fb84a6f2.png)

Есть несколько приёмов (например, [самоинъекция](https://stackoverflow.com/questions/43280460/spring-self-injection-for-transactions/43282215)), которые можно использовать, чтобы обойти это ограничение. Но главный вывод: всегда помните о границах транзакций прокси.